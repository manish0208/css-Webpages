<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>class-36-JS</title>
</head>
<body>
    <script>
        /*var a = [1,5,7,9,4,3,5,10,2,6];
        var min = a[0];
        var max = a[0];
        var mi;
        var ma;
        var temp = 0;
        for(var i=0; i<a.length; i++){
            if(a[i] < min){
                min = a[i];
                mi = i;
            }   
            if(a[i]> max){
                max = a[i];
                ma = i;
            }
            temp = a[mi];
            a[mi] = a[ma];
            a[ma] = temp;
        }
        */
        
       // var minimun = min;
        /*for(var i=0; i<a.length; i++){
            if(a[i]==max){
                a[i] = min;
            }
            else if(a[i]==minimun){
                a[i] = max;
            }
        }*/

        //console.log(a);
        //console.log("minimum -> "+min);
        //console.log("maximum -> "+max);
        
        /*
        // replace all spaces' ' with '%20'
        var string = "I am A very Good Boy";
        console.log(string.replaceAll(' ','%20'));
        */

        
        //compression of string
        /*
        var string = "aabcccccaa";
        var cmpstr = "";
        var count = 0;
        for(var i=0; i<string.length; i++){
            //for(j=i+1; j<string.length; i++){
                count++;
                if(string.charAt[i] == string.charAt[i+1]){
                    count+1;
                    cmpstr = cmpstr + string.charAt[i]+count;
                }
                //else if(string[i] != string[j]){
                //    b
                //}
            //}
        }
        console.log(cmpstr);
        */
        


        // home work
        /*
        Implement an algorithm to determine if a string has all unique characters. 
        What if you cannot use additional data structures?
        Given two strings, write a method to decide if one is a permutation of the
        other.
        */

       /*
        You have 1000 bottles of soda, and exactly one is poisoned. You have 10 test strips which
        can be used to detect poison. A single drop of poison will turn the test strip positive permanently.
        You can put any number of drops on a test strip at once and you can reuse a test strip as many times
        as you'd like (as long as the results are negative). However, you can only run tests once per day and
        it takes seven days to return a result. How would you figure out the poisoned bottle in as few days
        as possible?
        */


        /* 
           Grid: Imagine a robot sitting on the upper left corner of grid with r rows and c columns.
           The robot can only move in two directions, right and down, but certain cells are "off limits" such that
           the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to
           the bottom right.
           
           Arraylist<Point> getPath(boolean[][] maze) {
        if (maze == null I I maze.length == 0) return null;
        ArrayList<Point> path = new Arraylist<Point>();
        if (getPath(maze, maze.length - 1, maze[0].length - 1, path)) {
        return path;
        }
        return null;
        }
    
         boolean getPath(boolean[][] maze, int row, int col, Arraylist<Point> path) {
         // If out of bounds or not available, return.
         if (col < 0 11 row < 0 11 !maze[row][col]) {
         return false;
         }
        
         boolean isAtOrigin =(row == 0) && (col == 0);
        
         // If there's a path from the start to here, add my location. 
         if (isAtOrigin I I getPath(maze, row, col - 1, path) I I
         getPath(maze, row - 1, col, path)) {
         Point p = new Point(row, col);
         path.add(p);
         return true;
         }
        
         return false;
         }
         */


         /*
            Write code to partition a linked list around a value x, such that all nodes less than x come
            before all nodes greater than or equal to x. If x is contained within the list, the values of x only need
            to be after the elements less than x (see below). The partition element x can appear anywhere in the
            "right partition"; it does not need to appear between the left and right partitions.
            EXAMPLE
            Input:
            Output:
            3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 [partition= 5]
            3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8
            }
        */


    </script>
</body>
</html>